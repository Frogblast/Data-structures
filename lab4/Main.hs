import Route
import Graph
import qualified Data.PSQueue as PQ
import Data.List
import System.Directory.Internal.Prelude (getArgs)
import qualified Data.Map as M


-- CALCULATE SHORTEST PATH
{- 
Checks if the destination is actually reachable from the source,
if it is it uses a helper functions to get a list of stops along the path
-}
shortestPath :: (Ord a, Ord b, Num b) => Graph a b -> a -> a -> Maybe ([a], b)
shortestPath g from to = if from == to
  then Just ([to], 0)
  else
  let m = dijkstra g from in case M.lookup to m of
    Nothing -> Nothing
    Just aPath -> Just (backtrackPath m to from [], snd aPath)

{-
From a map of: destinationNode (previousNode, costToNode), generated by Dijkstra's algorithm,
we trace the path from the destination back to the startnode. By walking 'backwards' we ensure the path is actually the fastest one.
-}
backtrackPath :: (Ord a, Num b) => M.Map a (a,b) -> a -> a -> [a] -> [a]
backtrackPath m to from names = if to == from
  then to : names
  else backtrackPath m prev from (to : names)
  where
    Just prevTup = M.lookup to m
    prev = fst prevTup

-- GRAPH BUILDER FUNCTIONS --
{- Builds a graph from each line in the list -}
buildGraphFromLineTableList :: [LineTable] -> Graph String Integer -> Graph String Integer
buildGraphFromLineTableList [] g = g
buildGraphFromLineTableList [l] g = buildGraphFromLineTable l g
buildGraphFromLineTableList (l:ls) g = buildGraphFromLineTableList ls (buildGraphFromLineTable l g)

buildGraphFromLineTable :: LineTable -> Graph String Integer -> Graph String Integer
buildGraphFromLineTable lt g = addEdges g (lineTableToEdges lt)

lineTableToEdges :: LineTable -> [Edge String Integer]
lineTableToEdges lt = lineStopToEdges(stops lt)

lineStopToEdges :: [LineStop] -> [Edge String Integer]
lineStopToEdges [] = []
lineStopToEdges [single] = [Edge (stopName single) 0 (stopName single)]
lineStopToEdges (x:y:ls) = Edge(stopName x) (time y) (stopName y) : lineStopToEdges (y:ls)

addStopsToGraph :: [String] ->  Graph String Integer -> Graph String Integer
addStopsToGraph [] g = g
addStopsToGraph [stop] g = addEdge g (Edge stop 0 stop)
addStopsToGraph (s:ss) g = addStopsToGraph ss (addEdge g (Edge s 0 s))

-- helper to keep graph being generic
stopsToStrings :: [Stop] -> [String]
stopsToStrings [] = []
stopsToStrings [s] = [name s]
stopsToStrings (s:ss) = name s: stopsToStrings ss


main :: IO ()
main = do
 [stopsFile, linesFile, to, from] <- getArgs
 Right lines <- readLines linesFile
 Right stops <- readStops stopsFile
 let stopNames = stopsToStrings stops
 let graphLines = buildGraphFromLineTableList lines emptyGraph 
 let graph = addStopsToGraph stopNames graphLines
  
 case shortestPath graph to from of
  Just (stops, time) -> putStr $ show time ++ "\n" ++ unlines stops
  Nothing -> putStr "Route not found"